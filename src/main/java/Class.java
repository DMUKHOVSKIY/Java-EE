public class Class {
//    ORM [object-relational mapping(объектно реляционное отображение)] - технология, которая помогает нам в объектно
//    ориентированных языках программирования абстрагироваться от низкоуровневых операций, связаных с реляционными БД.
//    У этой технологии в приципе всегда есть, кто ее имплементирует (библиотеки, фреймворки). У нас в джава есть
//    нативным образом JDK, JDBC интерфейс. Мы можем просто взять и скачать драйвер для опредённой БД и все будет
//    работать, но у нас были неудобства. Чтобы сохранить 1 объект мы его берём. Потом разбираем. Потом берём
//    PrepearStatement. Потом делаем setLong, setString и тд. и вроде select пошёл, но мы эту сущность
//    разбирали - брали объект  (через геттеры его поля) и в prepearStatement его подготавливали. Но это сейчас
//    считается очень низкоуровневым вариантом работы с БД в java. Второй кейс - это когда мы достаем набор объектов
//    через selectSQL и берем ResultSet и через while/iterable начинаем высасывать все данные за итерацию
//    (опять создавать entity и впихивать через конструктор/сеттер/билдер), но это тоже низкоуровневая операция.
//    ORM - переосмысление работы в объектно ориетированном яп с реляционной БД. Потому что реляционно ориентированная
//    БД - это не объектно ориентированная БД. Там данные хранятся в виде таблиц. ORM - берёт на себя все обязанности
//    по связыванию данных и говорит "давай я буду все за тебя делать, а ты просто будешь просто говорить, что сделать
//    в контексте какого-то определённого типа/сущности".
//    По факту реализация ORM (в нашем случае Hibernate) - берёт на себя обязанности по низкоуровневой работе.
//    Hibernate работает поверх JDBC
//    Hibernate или ORM - это упрощение работы с реляционной БД
//    ORM - не всегда быстро работает. Поэтому в Hibernate пердусмотрен кэш.
//    Есть проекты, где лучше использовать JDBC, а не Hibernate
//    Hibernate - серцифицированный имплеметнатор JPA(спецификация)
//    Hibernate - библиотека, которая дает нам возможность проще работать с данными в реляционно й БД.
//    Hibernate идет в свяке с классическим Spring Framework. К буту мы будем подключать JPA.
//    Hibernate 5 - последняя версия на данный момент
//    Чтобы настроить спринг и гибернейт вместе надо работать с интергационноым слоем спринга(модуль  Spring ORM).
//    Нам надо сконфигурировать 3 бина через этот модуль. Если мы подключим гибернейт без этой прослойки и подрубим
//    только ядро гибергнейта, то он будет работать, но работать некорректно. У нас не будет таких фишек, как
//    декларативное управление транзакциями (через аннотацию transaction).
//    Жизненный цикл entity и cache:
//    Начнём с кэша:
//    В гибернейт предусмотрена система кэширования для увеличения произовдительности.
//    Кэш в гибернейте делится на 3 вида (уровни кэша): 1 уровень, 2 уровень, 3 уровень(query cache)
//    1 уровень кэша - включен по умолчанию и его отключить нельзя. Он работает на уровне сессии
    //Например если мы будем 2 раза вызывать  session.get(User.class, id), то при 2 попытке user будет нам передаваться из кэша, а не из БД
//    2 уровень кэша -  нужно включать и настраивать (при настройке нужно выбирать провайдера (где это все будет храниться)).
//    Он работает на уровне sessionFactory.
    //Например если мы даже сделаем session.close() (из предыдущего уровня кэша), то все равно session2.get(User.class, id) пойдет в кэш, а не в БД
//    3 уровень - работает на уровне запросов (session.createQuery()). Нужно включать и настраивать
    //Например, при вызове 2 одинаковых запросов (session.createQuery("from User where username = :un", User.class)), при 2 попытке мы будем получать Query из кэша
//    Жизненный цикл entity(фотка):
//    Сразу как мы создали юзера у него состояние - transient
//    Как только мы отдаем нашего юзера в метод session.save() - он становится persistent
//    Как только мы вызовем session.close() - состояние entity становится detached
    //Это(состояние) нужно для того, чтобы гибернейт знал, какие методы можно вызывать

}
